"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.search = void 0;
const type_1 = require("./type");
const stream_1 = require("stream");
const got_1 = __importDefault(require("got"));
const form_data_1 = __importDefault(require("form-data"));
const cheerio_1 = __importDefault(require("cheerio"));
const crypto_1 = __importDefault(require("crypto"));
async function search(input, options) {
    const response = await requestSearch(input, options);
    return handleSearch(response, options);
}
exports.search = search;
const WebsiteUrls = {
    www: 'https://iqdb.org/',
    '3d': 'https://3d.iqdb.org/'
};
const Services = Object.values(type_1.Service);
const ServiceIdMappings = {
    [type_1.Service.Danbooru]: 1,
    [type_1.Service.Konachan]: 2,
    [type_1.Service.Yandere]: 3,
    [type_1.Service.Gelbooru]: 4,
    [type_1.Service.SankakuChannel]: 5,
    [type_1.Service.EShuushuu]: 6,
    [type_1.Service.Zerochan]: 11,
    [type_1.Service.AnimePictures]: 13,
    [type_1.Service.ThreeDBooru]: 7,
    [type_1.Service.IdolComplex]: 9
};
const SourceNamedServiceMappings = Services.reduce((acc, service) => {
    const lowerCase = service.toLowerCase();
    acc[lowerCase] = service;
    acc[lowerCase.replace(/\s/g, '-')] = service;
    return acc;
}, {});
function requestSearch(input, options) {
    var _a, _b, _c, _d;
    const url = WebsiteUrls[((_a = options === null || options === void 0 ? void 0 : options.website) === null || _a === void 0 ? void 0 : _a.origin) || 'www'];
    if (!url) {
        throw new Error('Invalid website origin: ' + ((_b = options === null || options === void 0 ? void 0 : options.website) === null || _b === void 0 ? void 0 : _b.origin));
    }
    const formData = new form_data_1.default();
    if (input instanceof Buffer || input instanceof stream_1.Readable) {
        const length = Math.ceil(Math.random() * 10 + 5);
        const filename = (options === null || options === void 0 ? void 0 : options.filename) || crypto_1.default.randomBytes(length).toString('hex');
        formData.append('file', input, { filename });
    }
    else if (typeof input === 'string') {
        formData.append('url', input);
    }
    else {
        throw new Error('Expected input to be a string, buffer or a Readable stream');
    }
    if (((_c = options === null || options === void 0 ? void 0 : options.website) === null || _c === void 0 ? void 0 : _c.services) && Array.isArray((_d = options === null || options === void 0 ? void 0 : options.website) === null || _d === void 0 ? void 0 : _d.services)) {
        for (const service of options.website.services) {
            const id = ServiceIdMappings[service];
            id && formData.append('service[]', id);
        }
    }
    if (options === null || options === void 0 ? void 0 : options.ignoreColors) {
        formData.append('forcegray', true);
    }
    const requestOptions = got_1.default.mergeOptions((options === null || options === void 0 ? void 0 : options.requestOptions) || {}, {
        url,
        method: 'POST',
        responseType: 'text',
        headers: formData.getHeaders(),
        body: formData
    });
    return (0, got_1.default)(requestOptions).text();
}
function handleSearch(response, options) {
    const $ = cheerio_1.default.load(response);
    const error = parseError($);
    if (error) {
        throw new Error(error);
    }
    const metadata = parseMetadata($);
    const results = parseResults($, options === null || options === void 0 ? void 0 : options.pickOtherResults);
    return {
        ...metadata,
        results
    };
}
function parseError($) {
    const $errEl = $('body .err');
    if (($errEl === null || $errEl === void 0 ? void 0 : $errEl.length) > 0) {
        return $errEl.first().text();
    }
}
function parseMetadata($) {
    const $searchedEls = $('body p');
    const $searchedEl = $searchedEls.map((_, $el) => {
        const text = $($el).text().toLowerCase();
        if (text.startsWith('searched')) {
            return $el;
        }
        return undefined;
    });
    const searchedText = $searchedEl.text();
    const searchedTextParts = searchedText.split(' ');
    const searched = parseInt(searchedTextParts[1].replace(/,/g, '').trim());
    const timeSeconds = parseFloat(searchedTextParts[4].trim());
    const timeMilliseconds = timeSeconds * 1000;
    const $yourImageEl = $('body div#pages').children().first().find('img');
    const yourImageSrc = $yourImageEl.attr('src');
    const fixedYourImageSrc = fixedHref(yourImageSrc);
    return {
        searched,
        timeSeconds,
        timeMilliseconds,
        thumbnailSrc: fixedYourImageSrc,
        otherSearchHrefs: {
            saucenao: `https://saucenao.com/search.php?&url=${fixedYourImageSrc}`,
            ascii2d: `https://ascii2d.net/search/url/${fixedYourImageSrc}`,
            google: `https://lens.google.com/uploadbyurl?url=${fixedYourImageSrc}`,
            tineye: `https://tineye.com/search?url=${fixedYourImageSrc}`
        }
    };
}
function parseResults($, pickOtherResults) {
    let results = $('body div#pages')
        .children()
        .map((_, $pageEl) => parseResultsPage($, $pageEl))
        .get();
    const $moreEl = pickOtherResults ? $('body div#more1') : undefined;
    if ($moreEl && $moreEl.length > 0) {
        const moreResults = $($moreEl).find('div.pages')
            .children()
            .map((_, $pageEl) => parseResultsPage($, $pageEl))
            .get();
        if (moreResults.length > 0) {
            results = results.concat(moreResults);
        }
    }
    return results;
}
function parseResultsPage($, $pageEl) {
    const $rows = $($pageEl).find('table tr');
    if ($rows.length <= 0)
        return undefined;
    const $matchEl = $($rows[0]).find('th');
    const $thumbnailLinkEl = $($rows[$matchEl.length]).find('td a');
    const $thumbnailImageEl = $($thumbnailLinkEl).find('img');
    if ($thumbnailImageEl.length <= 0)
        return undefined;
    const matchText = $matchEl.length > 0 ? $matchEl.text().toLowerCase() : 'other';
    const thumbnailLinkHref = $thumbnailLinkEl.attr('href');
    const thumbnailImageSrc = $thumbnailImageEl.attr('src');
    const thumbnailImageAlt = $thumbnailImageEl.attr('alt');
    const match = matchText.replace(/match/g, '').trim();
    const thumbnail = {
        src: thumbnailImageSrc,
        fixedSrc: fixedHref(thumbnailImageSrc),
        ...parseImageProperties(thumbnailImageAlt)
    };
    const $sourceEl = $($rows[$matchEl.length + 1]).find('td');
    const firstSource = $sourceEl.clone().children().remove().end().text().trim().toLowerCase();
    const otherSources = $sourceEl.find('span.el a').map((_, $el) => {
        const ref = $($el);
        const service = ref.text().trim().toLowerCase();
        const href = ref.attr('href');
        return {
            service: SourceNamedServiceMappings[service],
            href,
            fixedHref: fixedHref(href)
        };
    }).get();
    const sources = [
        {
            service: SourceNamedServiceMappings[firstSource],
            href: thumbnailLinkHref,
            fixedHref: fixedHref(thumbnailLinkHref)
        }
    ].concat(otherSources);
    const $dimensionEl = $($rows[$matchEl.length + 2]).find('td');
    const dimensionOrTypeText = $dimensionEl.text().trim();
    const dimensionOrTypeMatch = /^(\d+).?(\d+)\s?\[(\w+)\]|\[(\w+)\]$/.exec(dimensionOrTypeText);
    let width = 0;
    let height = 0;
    let type = 'unrated';
    if (dimensionOrTypeMatch) {
        width = dimensionOrTypeMatch[1] ? parseInt(dimensionOrTypeMatch[1]) : 0;
        height = dimensionOrTypeMatch[2] ? parseInt(dimensionOrTypeMatch[2]) : 0;
        type = (dimensionOrTypeMatch[3] || dimensionOrTypeMatch[4]).toLowerCase();
    }
    const $similarityEl = $($rows[$matchEl.length + 3]).find('td');
    const similarityTexts = $similarityEl.text().trim().split(' ');
    const similarity = parseInt(similarityTexts[0].replace('%', ''));
    const similarityPercentage = similarity / 100;
    return {
        match,
        thumbnail,
        sources,
        width,
        height,
        type,
        similarity,
        similarityPercentage
    };
}
function fixedHref(href) {
    if (href[0] === '/' && href[1] === '/') {
        return 'http:' + href;
    }
    else if (href[0] === '/') {
        return 'https://iqdb.org' + href;
    }
    return href;
}
function parseImageProperties(alt) {
    const parts = alt.split(' ');
    const properties = {};
    let tmp = '';
    for (const part of parts) {
        if (part.charAt(part.length - 1) === ':') {
            tmp = part.substring(0, part.length - 1).toLowerCase();
            continue;
        }
        const value = properties[tmp];
        value
            ? (!Array.isArray(value) ? (properties[tmp] = [value]) : value).push(part)
            : properties[tmp] = part;
    }
    return {
        rating: properties.rating,
        score: properties.score ? parseInt(properties.score) : undefined,
        tags: fixedTags(properties.tags)
    };
}
function fixedTags(tags) {
    if (!tags)
        return undefined;
    if (typeof tags === 'string')
        return [tags];
    const newTags = [];
    for (const tag of tags) {
        const parts = tag.split(',');
        for (let part of parts) {
            part = part.trim();
            if (part.length > 0) {
                newTags.push(part);
            }
        }
    }
    return newTags;
}
//# sourceMappingURL=api.js.map